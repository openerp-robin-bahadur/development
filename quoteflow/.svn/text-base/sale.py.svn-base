from openerp.osv import fields, osv
from openerp.tools.translate import _
from openerp import netsvc

class sale_order(osv.osv):
    _inherit='sale.order'
    _description='Quotation Flow'

    

    def print_direct_report(self,cr,uid,ids,context=None):
        assert len(ids) == 1, 'This option should only be used for a single id at a time'
        global name
        state_condt=self.browse(cr,uid,ids[0]).state
        if state_condt=='approved':
            name="quotation.sale.order2"
        else:
            name="quotation.sale.order"
        datas={'ids': ids,}
        return {
                'type': 'ir.actions.report.xml',
                'report_name': name,
                'datas': datas,
                }



    def create_invoice(self,cr,uid,ids,context=None):
        invoice_obj=self.pool.get('account.invoice')
        sale_order_line_obj=self.browse(cr,uid,ids)
        
        for each in sale_order_line_obj:

            vals={}
            vals.update({
            'partner_id':each.partner_id.id,
            'date_invoice':each.date_order,
            'account_id':each.partner_id.property_account_receivable.id,
            'origin':each.name




            })

            sale_create_id=invoice_obj.create(cr,uid,vals,context=None)

            for x in each.order_line:
                    list_l= [y.id for y in x.tax_id]

                    product_get=x.product_id
                    line_vals={

                    'product_id':product_get.id,

                    'name':x.name,

    #           'date_planed':x.'date_planed',
                    'quantity':x.product_uom_qty,

                    'invoice_id':sale_create_id,
                    'price_unit':x.price_unit,
                    'date_planned':each.date_order,
                    'invoice_line_tax_id':[(6, 0, list_l)],
                    'price_unit':x.price_unit,
                    'sale_order_line_id':x.id




                        }
                    self.pool.get('account.invoice.line').create(cr,uid,line_vals,context=None)


            self.write(cr,uid,[each.id],{'state':'approved','x_signed_flag':True,'old_price_total':each.amount_total})
            new_group_ids=self.pool.get('res.groups').search(cr,uid,[('notify_email','in',['notify_account','notify_manager','notify_both'])])


            for follower_id in self.pool.get('res.groups').browse(cr,uid,new_group_ids):
                    for users in follower_id.users:
                        if users.email and users.partner_id.email:

                            mail_mail = self.pool.get('mail.mail')
                            # the invite wizard should create a private message not related to any object -> no model, no res_id
                            mail_id = mail_mail.create(cr, uid, {
                                'model': 'sale.order',
                                'res_id': each.id,
                                'subject': _('Modification in Quotation # %s') % (each.name,),
                                'body_html': 'This is to notify that Total Amount for %s Quotation is changed' % (each.name,),
                                'auto_delete': True,
                                }, context=context)
                            mail_mail.send(cr, uid, [mail_id], recipient_ids=[users.partner_id.id], context=context)
            return True

#           
    def show_invoice(self,cr,uid,ids,context=None):
         mod_obj = self.pool.get('ir.model.data')
         res = mod_obj.get_object_reference(cr, uid, 'account', 'invoice_form')
         res_id = res and res[1] or False
         invoice_id=self.pool.get('account.invoice').search(cr,uid,[('origin','=',self.browse(cr,uid,ids[0]).name)])
        

         return{
                'view_type': 'form',
                'view_mode': 'form',
                'res_model': 'account.invoice',
                'view_id': [res_id],
                'type': 'ir.actions.act_window',
                'nodestroy': True,
                'target': 'current',

                'context': "{'type':'out_invoice'}",
                'res_id':invoice_id[0]


                }

    def state_review(self,cr,uid,ids,context=None):
        for each in self.browse(cr,uid,ids):
            if not each.order_line:
              raise osv.except_osv(_('Error!'), _('Order Lines are not mentioned'))
            else:
                self.write(cr,uid,[each.id],{'state':'review'})
        return True

    def act_draft(self,cr,uid,ids,context=None):

        
        for each in self.browse(cr,uid,ids):
            self.write(cr,uid,[each.id],{'state':'draft'})
        return True

    def act_approve(self,cr,uid,ids,context=None):
        print"act approve() callled"
        for each in self.browse(cr,uid,ids):
            self.write(cr,uid,[each.id],{'state':'approved'})

            if each.x_signed_flag and each.old_price_total != each.amount_total:
                new_group_ids=self.pool.get('res.groups').search(cr,uid,[('notify_email','in',['notify_account','notify_manager','notify_both'])])


                for follower_id in self.pool.get('res.groups').browse(cr,uid,new_group_ids):
                    for users in follower_id.users:
                        if users.email and users.partner_id.email:

                            mail_mail = self.pool.get('mail.mail')
                            # the invite wizard should create a private message not related to any object -> no model, no res_id
                            mail_id = mail_mail.create(cr, uid, {
                                'model': 'sale.order',
                                'res_id': each.id,
                                'subject': _('Modification in Quotation # %s') % (each.name,),
                                'body_html': 'This is to notify that Total Amount for %s Quotation is changed' % (each.name,),
                                'auto_delete': True,
                                }, context=context)
                            mail_mail.send(cr, uid, [mail_id], recipient_ids=[users.partner_id.id], context=context)
        return True

    def act_waiting_for_approve(self,cr,uid,ids,context=None):
        print"act approve() callled"
        for each in self.browse(cr,uid,ids):
            self.write(cr,uid,[each.id],{'state':'waiting_approved_signature'})
        return True

    def act_reject_signature(self,cr,uid,ids,context=None):
        print"act approve() callled"
        for each in self.browse(cr,uid,ids):
            self.write(cr,uid,[each.id],{'state':'approved'})
        return True



    def action_quotation_send(self, cr, uid, ids, context=None):
        '''
        This function opens a window to compose an email, with the edi sale template message loaded by default
        '''
        assert len(ids) == 1, 'This option should only be used for a single id at a time.'
        ir_model_data = self.pool.get('ir.model.data')
        
        try:
            template_id = ir_model_data.get_object_reference(cr, uid, 'quoteflow', 'email_send_signing_id_approve')[1]
            
        except ValueError:
            template_id = False
        try:
            compose_form_id = ir_model_data.get_object_reference(cr, uid, 'mail', 'email_compose_message_wizard_form')[1]
        except ValueError:
            compose_form_id = False
        ctx = dict(context)
        ctx.update({
            'default_model': 'sale.order',
            'default_res_id': ids[0],
            'default_use_template': bool(template_id),
            'default_template_id': template_id,
            'default_composition_mode': 'comment',
            'mark_so_as_sent': True,
            
        })
        return {
            'type': 'ir.actions.act_window',
            'view_type': 'form',
            'view_mode': 'form',
            'res_model': 'mail.compose.message',
            
            'views': [(compose_form_id, 'form')],
            'view_id': compose_form_id,
            'target': 'new',
            'context': ctx,
            
        }
    




    _columns={
    'state':fields.selection([('draft','Draft'),('review',' In Review'),('approved','Approved'),('waiting_approved_signature','Waiting Signature Approval'),('quote_cancel','Cancelled')],'State',readonly=True),
    'billing_vendors':fields.selection([('chrysler','Chrysler'),('gm','GM'),('shift_digital','Shift Digital'),('dealer','Dealer')],"Billing Vendors"),

    }


    _defaults={
    'state':'draft'
    }

    def write(self,cr,uid,ids,vals,context=None):

#        wf_service = netsvc.LocalService("workflow")
#        print"wf_service=============",wf_service
#        wf_service.trg_validate(uid, 'sale.order', ids[0], 'action_onchange_write', cr)

        
        if vals.get('state')!="waiting_approved_signature" and vals.get('state')!="quote_cancel":

            res = self.read(cr,uid,ids,['state'])

            state_status=res[0].get('state')


            if state_status=="approved":
                 vals.update({'state':'draft'})
                 new_group_ids=self.pool.get('res.groups').search(cr,uid,[('notify_email','=','notify_manager')])

                 if self.browse(cr,uid,ids[0]).x_signed_flag:
                     
                     for follower_id in self.pool.get('res.groups').browse(cr,uid,new_group_ids):
                        for users in follower_id.users:
                            if users.email and users.partner_id.email:

                                mail_mail = self.pool.get('mail.mail')
                                # the invite wizard should create a private message not related to any object -> no model, no res_id
                                mail_id = mail_mail.create(cr, uid, {
                                    'model': 'sale.order',
                                    'res_id': ids[0],
                                    'subject': _('Modification in Quotation # %s') % (self.browse(cr,uid,ids[0]).name),
                                    'body_html': 'This is to notify that Total Amount for %s Quotation is changed' % (self.browse(cr,uid,ids[0]).name,),
                                    'auto_delete': True,
                                    }, context=context)
                                mail_mail.send(cr, uid, [mail_id], recipient_ids=[users.partner_id.id], context=context)
        return super(sale_order,self).write(cr,uid,ids,vals,context)


sale_order()

