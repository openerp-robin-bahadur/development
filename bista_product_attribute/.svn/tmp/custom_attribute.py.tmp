# -*- encoding: utf-8 -*-
###############################################################################
#                                                                             #
#   base_attribute.attributes for OpenERP                                     #
#   Copyright (C) 2011 Akretion Benoît GUILLOT <benoit.guillot@akretion.com>
#   Copyright (C) 2013 Akretion Raphaël VALYI <raphael.valyi@akretion.com>
#                                                                             #
#   This program is free software: you can redistribute it and/or modify      #
#   it under the terms of the GNU Affero General Public License as            #
#   published by the Free Software Foundation, either version 3 of the        #
#   License, or (at your option) any later version.                           #
#                                                                             #
#   This program is distributed in the hope that it will be useful,           #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of            #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             #
#   GNU Affero General Public License for more details.                       #
#                                                                             #
#   You should have received a copy of the GNU Affero General Public License  #
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.     #
#                                                                             #
###############################################################################

import ast
from openerp.osv import orm, fields
from openerp.osv.osv import except_osv
from openerp.tools.translate import _
from lxml import etree
from unidecode import unidecode # Debian package python-unidecode
import re
from osv import osv, fields


class attribute_attribute(orm.Model):
    _inherit = "attribute.attribute"

    def _build_attribute_field(self, cr, uid, main_group, attribute, context=None):
        parent = etree.SubElement(main_group, 'group', colspan="2", col="2")
        kwargs = {'name': "%s" % attribute.name}
        if attribute.ttype in ['many2many', 'text']:
            parent = etree.SubElement(parent, 'group', colspan="2", col="2")
            etree.SubElement(parent,
                                   'separator',
                                    string="%s" % attribute.field_description,
                                    colspan="4")
            kwargs['nolabel'] = "1"
        if attribute.ttype in ['many2one', 'many2many']:
            if attribute.relation_model_id:
                # attribute.domain is a string, it may be an empty list
                try:
                    domain = ast.literal_eval(attribute.domain)
                except ValueError:
                    domain = None
                if domain:
                    kwargs['domain'] = attribute.domain
                else:
                    ids = [op.value_ref.id for op in attribute.option_ids]
                    kwargs['domain'] = "[('id', 'in', %s)]" % ids
            else:
                kwargs['domain'] = "[('attribute_id', '=', %s)]" % attribute.attribute_id.id
        kwargs['context'] = "{'default_attribute_id': %s}" % attribute.attribute_id.id
        kwargs['required'] = str(attribute.required or
                                 attribute.required_on_views)
        field = etree.SubElement(parent, 'field', **kwargs)
        orm.setup_modifiers(field, self.fields_get(cr, uid, attribute.name,
                                                   context))
        return parent

    def _build_attributes_notebook(self, cr, uid, attribute_group_ids,
                                   context=None):
        notebook = etree.Element('notebook', name="attributes_notebook",
                                 colspan="4")
        toupdate_fields = []
        grp_obj = self.pool.get('attribute.group')
        for group in grp_obj.browse(cr, uid, attribute_group_ids,
                                    context=context):
            page = etree.SubElement(notebook, 'page',
                                    string=group.name.capitalize())
            main_group = etree.SubElement(page, 'group', colspan="4", col="4")
            for attribute in group.attribute_ids:
                if attribute.name not in toupdate_fields:
                    toupdate_fields.append(attribute.name)
                    self._build_attribute_field(cr, uid, main_group, attribute,
                                                context=context)
        return notebook, toupdate_fields

    
    _columns={
                
#                'domain':fields.char('Domain', size=256, help="The optional domain to restrict possible values for relationship fields, "),
                'active':fields.boolean('Active'),
                'sales_price': fields.float('Sale Price'),
                'cost_price': fields.float('Cost Price'),
                'price':fields.selection([('per_unit','Per Unit'),('based_order_lines','Per Order Lines')],"Calculation Method"),
                'is_create':fields.boolean("create",readonly=True,invisble=True),


                    }

    _defaults = {
                 'active':True
                }

    

    def create(self, cr, uid, vals, context=None):
        """ Create an attribute.attribute
        """
        
        fields_obj = self.pool.get("ir.model.fields")
        if 'name' in vals and vals['name']:
            old_field = self.search(cr, uid, [('name','=',vals['name'])])
            if not old_field:
                 old_ir_field = fields_obj.search(cr, uid, [('name','=',vals['name'])])
                 if old_ir_field:
                     fields_obj.unlink(cr, uid, old_ir_field)
        global search_model_ids1
        try:
            if search_model_ids1:
                pass
        except:
            search_model_ids1 = []

        vals['state'] = 'manual'

        update_model_ids=self.pool.get('ir.model').search(cr,uid,[('model', 'in',['base.product.template','sale.order.line'])])
        if vals['model_id'] not in update_model_ids and len(vals['option_ids']) == 0:
            raise osv.except_osv(_('Error!'), _('Attribute must have atleast one active option line.'))

        vals['is_create']=True
        res = super(attribute_attribute, self).create(cr, uid, vals, context)
        model = self.read(cr, uid, res, ['model'])
        if res:
            if model['model'] == 'product.product' and not search_model_ids1:
                search_model_ids1=self.pool.get('ir.model').search(cr,uid,[('model', 'in',['base.product.template','sale.order.line'])])

        for each in search_model_ids1:
            search_model_ids1.remove(each)
            vals.update({'model_id' : each})
            res_copy_id = self.copy(cr, uid, res, vals, context)         

        return res

    def write(self, cr, uid,ids ,vals,context=None):
        """ Write method of attribute.attribute
        """
        global search_model_ids2
        try:
            if search_model_ids2:
                pass
        except:
            search_model_ids2 = []
        sol=self.browse(cr,uid,ids)
        res = super(attribute_attribute, self).write(cr, uid, ids,vals, context)
        if sol:
            if sol[0].model == 'product.product' and not search_model_ids2:
                search_model_ids2=self.search(cr,uid,[('name','=',sol[0].name),('model', 'in',['base.product.template','sale.order.line'])])
                
            
        for each in search_model_ids2:
            if 'option_ids' in vals:
                vals.pop('option_ids')
            search_model_ids2.remove(each)
            self.write(cr, uid, [each], vals, context)
        
        sol=self.browse(cr,uid,ids)
        if sol:
            if not sol[0].option_ids and sol[0].model == 'product.product':
                raise osv.except_osv(_('Error!'), _('Attribute must have atleast one active option line.'))

        return res
  



    def unlink(self, cr, uid,ids,context=None):


        fields_obj=self.pool.get("ir.model.fields")
        attr_records = self.browse(cr, uid, ids)
        for each_attr_record in attr_records:
            each_attr_record_name = each_attr_record.name

            attr_field_ids = self.search(cr, uid, [('name','=',each_attr_record_name)])

            ir_field_records = self.browse(cr,uid,attr_field_ids)
            ir_field_records_ids = []
            for each in ir_field_records:
                ir_field_records_ids.append(each.field_id.id)
            fields_obj.unlink(cr, uid, ir_field_records_ids)

        return super(attribute_attribute, self).unlink(cr, uid, ids, context=context)



attribute_attribute()



class attribute_option(orm.Model):
    _inherit = "attribute.option"
    _columns={
                'name': fields.char('Name', size=64, required=False),
                'active':fields.boolean('Active'),
                'sales_price': fields.float('Sale Price',required=True),
                'cost_price': fields.float('Cost Price'),
                'price':fields.selection([('per_unit','Per Unit'),('based_order_lines','Per Order Lines')],'Calculation Method',required=True),
                'attribute_id': fields.many2one('attribute.attribute','Product Attribute',required=True,ondelete='cascade'),
                'field_desc':fields.related('attribute_id','field_description',type='char',string="Field Label", store=True)
             }

    _defaults = {
                 'active':True
                }

    def create(self, cr, uid, vals, context=None):
        if 'sales_price' in vals and not vals['sales_price'] and 'cost_price' in vals and not vals['cost_price']:
            raise osv.except_osv(_('Error!'), _('Attribute option either have sale price or cost price greater than zero.'))
        res = super(attribute_option, self).create(cr, uid, vals, context)
        result = self.read(cr, uid, res, [])
        global search_model_ids3
        try:
            if search_model_ids3:
                pass
        except:
            search_model_ids3 = []
        val = self.browse(cr, uid, res)

        if res:
            if val.attribute_id.model == 'product.product' and not search_model_ids3:
                search_model_ids3 = self.pool.get('attribute.attribute').search(cr, uid, [('name','=',val.attribute_id.name),('model' ,'in',['base.product.template','sale.order.line'])])

        for each in search_model_ids3:
            search_model_ids3.remove(each)
            vals.update({'attribute_id' : each})
            res_copy_id = self.copy(cr, uid, res, vals, context)
        return res

    def write(self, cr, uid, ids, vals, context=None):
        val = self.browse(cr, uid, ids)
        res = super(attribute_option, self).write(cr, uid, ids, vals, context)
        
        global search_model_ids4
        try:
            if search_model_ids4:
                pass
        except:
            search_model_ids4 = []
        
        if res:
            if val[0].attribute_id.model == 'product.product' and not search_model_ids4:
                search_model_ids4 = self.pool.get('attribute.attribute').search(cr, uid, [('name','=',val[0].attribute_id.name),('model' ,'in',['base.product.template','sale.order.line']),('active','=','True')])
        for each in search_model_ids4:
            search_model_ids4.remove(each)
            search_id = self.search(cr, uid, [('attribute_id','=',each)])
            write_id = self.search(cr, uid, [('attribute_id','=',each),('sales_price','=',val[0].sales_price),('sequence','=',val[0].sequence),('cost_price','=',val[0].cost_price),('name','=',val[0].name),('active','=',val[0].active)])
            if write_id:
                self.write(cr, uid, [write_id[0]],vals)
#             else:
#                 print "==============create operation==========="
#                 vals.update({'attribute_id' : each})
#                 res_copy_id = self.copy(cr, uid, ids[0], vals, context)
        return res


    def unlink(self, cr, uid,ids,context=None):
        unlink_ids = []
        for val in self.browse(cr, uid, ids):
            search_model_ids5 = self.pool.get('attribute.attribute').search(cr, uid, [('name','=',val.attribute_id.name),('model' ,'in',['base.product.template','sale.order.line']),('active','=','True')])
            for each in search_model_ids5: 
                write_ids = self.search(cr, uid, [('attribute_id','=',each),('sales_price','=',val.sales_price),('sequence','=',val.sequence),('cost_price','=',val.cost_price),('name','=',val.name)])
                for each in write_ids:
                    unlink_ids.append(each)
            unlink_ids.append(val.id)
        return super(attribute_option, self).unlink(cr, uid, unlink_ids, context=context)

